#ifndef FREQ_ALG_H
#define FREQ_ALG_H

#include "matem.h"
#include <stdbool.h>
#include "FIFO.h"
#include "ErrHelper.h"
//#include <stdio.h>

#define DEV_SampleFreq  9600 //частота дискретизации АЦП
#define DEV_WorkFreq  50//частота сети 50/60 Гц
#define DEV_PeriodSamples (DEV_SampleFreq/DEV_WorkFreq)//Количество выборок за период
#define DEV_ADCSampleTime (1.0/DEV_SampleFreq)
#define BUFSIZE_LO 32
#define BUFSIZE_HI 256

//Хранит информацию о частоте(периоде) и промежуточные данные для расчета частотных параметров.
typedef struct 
{
	//Текущее значение периода сигнала по которму ведется работа устройства в выборках * 2^16
	int T;
	//буфер отсчетов
	Fifo_int sampleBufer;
	//текущее значение частоты для вывода пользователю [Гц] * 2^16
	int frequency;
	//текущее значение скорости изменения частоты [Гц/с] * 2^16
	int dfdt;
	//буфер значений скорости изменения периода сигнала
	Fifo_int dTdtbuf;
	//текущее значение скорости изменения периода сигнала в выборках за количество выборок 
	int dTdt;
	//буфер моментов перехода сигнала через ноль из "-" в "+" (в выборках * 2^16; старшие 2 байта целое, младщие 2 байта - дробная часть)
	Fifo_uint timeBuf;
	//буфер периодов сигнала в выборках
	Fifo_uint periodBuf;
	//Буфер значений частоты [Гц] * 2^16
	Fifo_int freqBuf;
	//счетчик выборок * 2^16
	unsigned int campleCounter;
	//Частота дискретизации сигнала [Гц]
	short sampleFreq;
	//флаг расчета частоты при данном вызове.
	bool isCalc;
	//Номинальная частота сети [Гц]
	short nomFreq;

} Freq;

typedef struct 
{
	Fifo_int samples;
	float result;
	float filtCoef[DEV_PeriodSamples];
} Filt;

typedef struct 
{
	Fifo_int samples;
	int64_t result;
	int64_t filtCoef[DEV_PeriodSamples];
} FiltInt;

//Хранит информацию о частоте(периоде) и промежуточные данные для расчета частотных параметров.Исполльзуется фильтр с float.
typedef struct 
{
	//Текущее значение периода сигнала по которму ведется работа устройства в выборках
	float T;
	//буфер отсчетов
	Fifo_float sampleBufer;
	//текущее значение частоты для вывода пользователю [Гц]
	float frequency;
	//текущее значение скорости изменения частоты [Гц/с]
	float dfdt;
	//буфер значений скорости изменения периода сигнала
	Fifo_float dTdtbuf;
	//текущее значение скорости изменения периода сигнала в выборках за количество выборок 
	float dTdt;
	//буфер моментов перехода сигнала через ноль из "-" в "+" (в выборках)
	Fifo_float timeBuf;
	//буфер периодов сигнала в выборках
	Fifo_float periodBuf;
	//Буфер значений частоты [Гц]
	Fifo_float freqBuf;
	//счетчик выборок
	unsigned short campleCounter;
	//Частота дискретизации сигнала [Гц]
	short sampleFreq;
	//Номинальная частота сети [Гц]
	short nomFreq;
	//структура для предварительного фильтьтра
	Filt filter;
	//флаг расчета частоты при данном вызове.
	bool isCalc;

} FreqF;


//Хранит информацию о частоте(периоде) и промежуточные данные для расчета частотных параметров. Исполльзуется фильтр с челочисленными данными.
typedef struct 
{
	//Текущее значение периода сигнала по которму ведется работа устройства в выборках
	float T;
	//буфер отсчетов
	Fifo_float sampleBufer;
	//текущее значение частоты для вывода пользователю [Гц]
	float frequency;
	//текущее значение скорости изменения частоты [Гц/с]
	float dfdt;
	//буфер значений скорости изменения периода сигнала
	Fifo_float dTdtbuf;
	//текущее значение скорости изменения периода сигнала в выборках за количество выборок 
	float dTdt;
	//буфер моментов перехода сигнала через ноль из "-" в "+" (в выборках)
	Fifo_float timeBuf;
	//буфер периодов сигнала в выборках
	Fifo_float periodBuf;
	//Буфер значений частоты [Гц]
	Fifo_float freqBuf;
	//счетчик выборок
	unsigned short campleCounter;
	//Частота дискретизации сигнала [Гц]
	short sampleFreq;
	//Номинальная частота сети [Гц]
	short nomFreq;
	//структура для предварительного фильтьтра
	FiltInt filter;
	//флаг расчета частоты при данном вызове.
	bool isCalc;

} FreqF_intFlt;

void signalShiftF (float *buffer, float signal, int length);

//Рассчитывает период и частоту сигнала по переходам через ноль. Используется FLOAT. С применением фильтра.
//Расчет периода ведется по среднему расстоянию между переходами через ноль из "-" в "+".
//Для расчета используется среднее время за 3 предыдущих периода. T = (t0-t3)/3.
//Функция вычисляет период сигнала в выборках.
//Вход:
//int sample - значение новой выборки;
//FreqF *fr - структура для хранения информации о частоте;
//Выход:
//float res - занчение частоы основной гармоники сигнала в Гц.
//
//Усреднение по трем периодам дает запаздывание результата измерения на 1.5 периода текущей частоты + запаздывание фильтра на 0.5. Например, при наличии df/dt != 0 результатом
//будет частота не в данный момент времени (переход чрез 0), а в момент времени отстающий от текущего на 2 периода назад. 
//При f = 50 Гц и df/dt = 5 Гц/с ~ 0.3/0.06, замер частоты будет запаздывать на 0.3/2 + 0.05 = 0.2 Гц, где 0.3 - изменение частоты за 3 периода, 0.06 - примерная длительность 3 периодов.
//errCode 0x3302, 0x3303, 0x3101
float periodCalcF_flt(int sample, FreqF *fr);

//Рассчитывает период и частоту сигнала по переходам через ноль. Используется FLOAT. С применением фильтра.
//Расчет периода ведется по среднему расстоянию между переходами через ноль из "-" в "+".
//Для расчета используется среднее время за 3 предыдущих периода. T = (t0-t3)/3.
//Функция вычисляет период сигнала в выборках.
//Вход:
//int sample - значение новой выборки;
//FreqF *fr - структура для хранения информации о частоте;
//Выход:
//float res - занчение частоы основной гармоники сигнала в Гц.
//
//Усреднение по трем периодам дает запаздывание результата измерения на 1.5 периода текущей частоты + запаздывание фильтра на 0.5. Например, при наличии df/dt != 0 результатом
//будет частота не в данный момент времени (переход чрез 0), а в момент времени отстающий от текущего на 2 периода назад. 
//При f = 50 Гц и df/dt = 5 Гц/с ~ 0.3/0.06, замер частоты будет запаздывать на 0.3/2 + 0.05 = 0.2 Гц, где 0.3 - изменение частоты за 3 периода, 0.06 - примерная длительность 3 периодов.
//errCode 0x3302, 0x3303, 0x3101
float periodCalcF_fltInt(int sample, FreqF_intFlt *fr);

//Расчет скорости изменения чатоты. Используется FLOAT.	
//df/dt расчитывается оп формуле df/dt = (f(n) - f(n-4) + f(n-1) - f(n-5)) / (t(n) - t(n-4) + t(n-1) - t(n-5)).
//На выходе = df/dt в Гц/c .
//errCode 0x3302, 0x3303
float calcDfDtF(FreqF* fr);

//Вычисляет дробную часть выборки момента перехода через ноль из "-" в "+".
//Исспользуется float
//errCode 0x3101
float nulpassF(float sample, float prev);

//Инициализация фильтра для расчета частоты. Исп. DSP
void FiltInitDSP(Filt * flt );

//Инициализация фильтра для расчета частоты
void FiltInit(Filt * flt );

//Инициализация фильтра для расчета частоты
void FiltIntInit(FiltInt * flt );

//КИХ фильтр работающий по DEV_PeriodSamples количеству выборок. Коэффициенты предварительно рассчитываются в FiltInit
//errCode 0x3302, 0x3303
float filter(int sample, Filt *filt);

//КИХ фильтр работающий по DEV_PeriodSamples количеству выборок. Коэффициенты предварительно рассчитываются в FiltInitDSP
//errCode 0x3302, 0x3303
float filterDSP(int sample, Filt *filt);

//КИХ фильтр работающий по DEV_PeriodSamples количеству выборок. Коэффициенты предварительно рассчитываются в FiltIntInit. Используется целочиленная математика.
//errCode 0x3302, 0x3303
int filterInt(int sample, FiltInt *filt);

//Инциализирует структуру для расчета частоты
//errCode 0x3301
FreqF_intFlt FreqFIntInit(void);

//Инциализирует структуру для расчета частоты
//errCode 0x3301
FreqF FreqFInit(void);

#endif //FREQ_ALG_H
