#ifndef MEAS_ALGS_H
#define MEAS_ALGS_H

#ifndef MSVC
	#define ARM_MATH_CM4
	#include "MK70F15.h"                    // Device header
	#include "arm_math.h"                   // ARM::CMSIS:DSP
#else
	#include "stdafx.h"
	#include <math.h>
#endif

#include <stdbool.h>
#include "FreqAlg.h"
#include "Complex.h"
#include "ErrHelper.h"
#include "FIFO.h"

#define DEV_numberAnalogChannels 1
#define DEV_MaxNumberAnalogChannels 16
#define DEV_sampleBuferCount (DEV_PeriodSamples*2)
#define DEV_LogicWorkTime 48 // количество выборок АЦП через котороые запускается расчет тействующих значений логики

typedef struct
{
	ComplexF * vect;
	int size;
} Vectors;

//Инициализация структуры Vectors
//Вход:
//int count - количество исспорльзуемых векторов
Vectors VectorsInit(int count);

//Функция линейной интерполяции сигнала
//Расчет времени ведется от конца массива
//Вход:
//int *buffer - указатель на массив выборок для инерполяции;
//int bufCoun - длинна буфера
//float dt - время между отсчетами (шаг по времени постоянный)
//float t - время, от конца массива, искомой точки
//Выход:
//координата точки по оси ординат
//errCode = 0x3304, 0x3302
float lineInterpolation(int *buffer, int bufCount, float dt, float t);

//Функция линейной интерполяции сигнала при применении циклического буфера.
//Логика fifo реализуется в самой функции (не опртимизировано).
//Расчет времени ведется от конца массива.
//Вход:
//Fifo_int * fifo - циклический буфер с исходными данными;
//float dt - время между отсчетами (шаг по времени постоянный)
//float t - время, от конца массива, искомой точки
//Выход:
//координата точки по оси ординат
//errCode = 0x3304, 0x3302, 0x3303
float lineInterpolation_fifo(Fifo_int * fifo, float dt, float t);

//Функция линейной интерполяции сигнала при применении циклического буфера.
//Логика fifo реализуется в самой функции (не опртимизировано).
//Расчет времени ведется от конца массива.
//Вход:
//int *buffer - указатель на массив выборок для инерполяции;
//int bufCoun - длинна буфера
//int bufHead - положение последней выборки в циклическом буффере
//float dt - время между отсчетами (шаг по времени постоянный)
//float t - время, от конца массива, искомой точки
//Выход:
//координата точки по оси ординат
//errCode = 0x3302, 0x3304
float lineInterpolation_fifo1(int *buffer, int bufCount, int bufHead, float dt, float t);

//Функция ресенмплинга. Использует линейную интерполяцию. Работет с входными значениями int. На выходе float[].
//Вход:
//int * buffer - указатель на буфер вхоных данных (выборок) (циклический буфер)
//int bufcount - длинна буфера
//int bufhead - текущее положение конца циклического буфера. Если использовать как простой буфер - то bufhead = bufcount.
//float dt - шаг по времени данных исходного буфера
//float resTime - время выходного буфера
//int resSampleCount - длинна выходного буфера в выборках
//float * res - указатель на выходной буфер длинной resSampleCount
//errCode = 0x3305, 0x3302, 0x3304
void resampling(int * buffer, int bufcount, int bufhead, float dt, float resTime, int resSampleCount, float * res);

//Функция ресенмплинга. Использует линейную интерполяцию. Работет с входными значениями int. Применяется при использовании реализованного алгоритма fifo.
//На выходе float[].
//Вход:
//_Fifo_int * buffer - указатель на буфер вхоных данных (выборок) (циклический буфер)
//float base_dt - шаг по времени исходного буфера
//float res_dt - шаг по времени выходного буфера
//int resSampleCount - длинна выходного буфера в выборках
//float * res - указатель на выходной буфер длинной resSampleCount
//errCode = 0x3305,0x3304, 0x3302, 0x3303
void resampling_fifo(Fifo_int * fifo, float base_dt, float res_dt, int resSampleCount, float * res);

//Расчет комплексной амплитуды сигнала первой гармоники по 32 точкам методом Фурье.
//На выходе амплитудное значение.
//Вход:
//float * buf - указатель на массив выборок сигнала для вычисления амплитуды.
//Для получения точного результата массив должен содержать данные ровно на 1 париод основной частоты.
//Для этого предварительно определяется частота синала и делается ресемплинг.
//Выход:
//ComplexF res - комплексная амплитуда перевой гармоники сигнала.
ComplexF fourier1st32s(float * buf);

//Расчет комплексной амплитуды сигнала X гармоники по 32 точкам методом Фурье.
//На выходе амплитудное значение.
//Для получения точного результата массив buf должен содержать данные ровно на 1 париод основной частоты.
//Для этого предварительно определяется частота синала и делается ресемплинг.
//Вход:
//float * buf - указатель на массив выборок сигнала для вычисления амплитуды.
//float * sinCoef - коэффициенты синусной составляющей ряда фурье для данной гармоники, 32 коэффициента. 
//float * cosCoef - коэффициенты косинусной составляющей ряда фурье для данной гармоники, 32 коэффициента.
//
//cosCoef[i] + j*sinCoef[i] = exp(-j*f*n*2*pi/N *(N-i-1), где N - кличество выборок за период,
//n - номер гармоники, f - частота первой гармоники, i - номер коэффициента.
//
//Выход:
//ComplexF res - комплексная амплитуда перевой гармоники сигнала.
ComplexF fourierX32s(float * buf, const float * sinCoef, const float *cosCoef);

//Расчет комплексной амплитуды сигнала 2-й гармоники по 32 точкам методом Фурье.
//На выходе амплитудное значение.
//Вход:
//float * buf - указатель на массив выборок сигнала для вычисления амплитуды.
//Для получения точного результата массив должен содержать данные ровно на 1 париод основной частоты.
//Для этого предварительно определяется частота синала и делается ресемплинг.
//Выход:
//ComplexF res - комплексная амплитуда перевой гармоники сигнала.
ComplexF fourier2nd32s(float * buf);

//Расчет комплексной амплитуды сигнала 3-й гармоники по 32 точкам методом Фурье.
//На выходе амплитудное значение.
//Вход:
//float * buf - указатель на массив выборок сигнала для вычисления амплитуды.
//Для получения точного результата массив должен содержать данные ровно на 1 париод основной частоты.
//Для этого предварительно определяется частота синала и делается ресемплинг.
//Выход:
//ComplexF res - комплексная амплитуда перевой гармоники сигнала.
ComplexF fourier3rd32s(float * buf);

//Расчет комплексной амплитуды сигнала 5-й гармоники по 32 точкам методом Фурье.
//На выходе амплитудное значение.
//Вход:
//float * buf - указатель на массив выборок сигнала для вычисления амплитуды.
//Для получения точного результата массив должен содержать данные ровно на 1 париод основной частоты.
//Для этого предварительно определяется частота синала и делается ресемплинг.
//Выход:
//ComplexF res - комплексная амплитуда перевой гармоники сигнала.
ComplexF fourier5th32s(float * buf);

//Расчет комплексной амплитуды сигнала 7-й гармоники по 32 точкам методом Фурье.
//На выходе амплитудное значение.
//Вход:
//float * buf - указатель на массив выборок сигнала для вычисления амплитуды.
//Для получения точного результата массив должен содержать данные ровно на 1 париод основной частоты.
//Для этого предварительно определяется частота синала и делается ресемплинг.
//Выход:
//ComplexF res - комплексная амплитуда перевой гармоники сигнала.
ComplexF fourier7th32s(float * buf);

//Расчет комплексной амплитуды сигнала 9-й гармоники по 32 точкам методом Фурье.
//На выходе амплитудное значение.
//Вход:
//float * buf - указатель на массив выборок сигнала для вычисления амплитуды.
//Для получения точного результата массив должен содержать данные ровно на 1 париод основной частоты.
//Для этого предварительно определяется частота синала и делается ресемплинг.
//Выход:
//ComplexF res - комплексная амплитуда перевой гармоники сигнала.
ComplexF fourier9th32s(float * buf);

//Адаптивный к частоте орган определения вектора первой гармоники на основе алгоритма Фурье.
//Определяет вкличину первой гармоники рассчетной частоты.
//Вход:
//Fifo_int * signal - циклически буфер выборок сигнала.
//float period - период основной частоты в выборках (20 мс (50 гц) = DEV_PeriodSamples выборок за период).
//Выход:
//ComplexF res - вектор первой гармоники рассчетной частоты.
//errCode = 0x3305,0x3304, 0x3302, 0x3303
ComplexF fourier1st32sFreq(Fifo_int * signal, float period);

//Вычисление вектора прямой последовательности по векторам трех фаз
//X1 = Xa + Xb * a + Xc * a^2
//Вход:
//ComplexF *phA - вектор фазы A
//ComplexF *phB - вектор фазы B
//ComplexF *phC - вектор фазы C
//Выход:
//ComplexF res - вектор прямой последовательности
ComplexF calcPhase2Sym1(ComplexF *phA, ComplexF *phB, ComplexF *phC);

//Вычисление вектора обратной последовательности по векторам трех фаз
//X1 = Xa + Xb * a^2 + Xc * a
//Вход:
//ComplexF *phA - вектор фазы A
//ComplexF *phB - вектор фазы B
//ComplexF *phC - вектор фазы C
//Выход:
//ComplexF res - вектор обратной последовательности
ComplexF calcPhase2Sym2(ComplexF *phA, ComplexF *phB, ComplexF *phC);

//Вычисление вектора нулевой последовательности по векторам трех фаз
//X1 = Xa + Xb * a^2 + Xc * a
//Вход:
//ComplexF *phA - вектор фазы A
//ComplexF *phB - вектор фазы B
//ComplexF *phC - вектор фазы C
//Выход:
//ComplexF res - вектор нулевой последовательности
ComplexF calcPhase2Sym0(ComplexF *phA, ComplexF *phB, ComplexF *phC);

//Вычисление вектора фазы A по симметричным составляющим фазы A
//XB = X1 + X2 + X0
//Вход:
//ComplexF *x1 - вектор прямой последовательности
//ComplexF *x2 - вектор обратной последовательности
//ComplexF *x0 - вектор нулевой последовательности
//Выход:
//ComplexF res - вектор фазы A
ComplexF calcSym2PhaseA(ComplexF *x1, ComplexF *x2, ComplexF *x0);

//Вычисление вектора фазы B по симметричным составляющим фазы A
//XB = X1 * a^2 + X2 * a + X0
//Вход:
//ComplexF *x1 - вектор прямой последовательности
//ComplexF *x2 - вектор обратной последовательности
//ComplexF *x0 - вектор нулевой последовательности
//Выход:
//ComplexF res - вектор фазы B
ComplexF calcSym2PhaseB(ComplexF *x1, ComplexF *x2, ComplexF *x0);

//Вычисление вектора фазы C по симметричным составляющим фазы A
//XB = X1 * a^2 + X2 * a + X0
//Вход:
//ComplexF *x1 - вектор прямой последовательности
//ComplexF *x2 - вектор обратной последовательности
//ComplexF *x0 - вектор нулевой последовательности
//Выход:
//ComplexF res - вектор фазы C
ComplexF calcSym2PhaseC(ComplexF *x1, ComplexF *x2, ComplexF *x0);

//Вычисление вектора фазы С по векторам фазы A, B и нулевого тока (1*Io).
//Вход:
//ComplexF *ia - вектор тока фазы A
//ComplexF *ib - вектор тока фазы B
//ComplexF *io - вектор тока нулевой последовательноти.
//Выход:
//ComplexF res - Вектор фазы C.
ComplexF calcIabo2Ic(ComplexF *ia, ComplexF *ib, ComplexF *io);

//Вычисление утроенного значения отсчета нулевой последовательности по отсчетм 3-х фаз.
//3xo = xa + xb + xc
//Вход:
//int xa - отсчет фазы A
//int xb - отсчет фазы B
//int xc - отсчет фазы C
//Выход
//int res - отсчет утроенного значения сигнала нулевой последовательности
int calc3XoSample(int xa, int xb, int xc);

//Расчет амплитуды сигнала "амплитудным" методом (peak-to-peak) по 32 выборкам.
//Возвращает среднне арифметическое между максимумами положительной и отрицательной полуволн.
//Данная реализация не чувствительна к постоянной составляющей в сигнале.
//Вход:
//float * buf - буффер входных выборок.
//Выход: 
//float res - амплитуда сигнала.
float peakToPeak(float * buf);

//Расчет амплитуды сигнала среднеквадратичным методом (RMS) по 32 выборкам.
//Вход:
//float * buf - буффер входных выборок.
//Выход: 
//float res - амплитуда сигнала.
float RMS32(float *buf);

//Рачет комплексной мошности по току и напряжению.
//Вход:
//ComplexF *current - комплексный вектор тока
//ComplexF *voltage - комплексный вектор напряжения
//Выход:
//ComplexF res - комплексный вектор мощности
ComplexF calcPower(ComplexF *current, ComplexF *voltage);

//Инициализация буфферов выборок каналов
void initSignalBufers(void);

//Процедура расчета комплексной амплитуды сигналов для текущего среза (момента времени) и частоты сети по первому каналу.
//Расчет векторов ведется с использованием информации о частоте.
//Использутся статически обьявленые буферы.
//Вход:
//int *signals - указатель на массив выборок каналов.
//FreqF *fr - указатель на структуру исп. для расчета частоты.
//Vectors *res - Указатель на структуру с искомыми векторами - выходной параметр (необходимо проинициализировать Vectors.size заранее).
//
//errCode 0x3305, 0x3302, 0x3303, 0x3304
void measNsignals(short *signals, FreqF *fr, Vectors *res);

#endif //MEAS_ALGS_H
